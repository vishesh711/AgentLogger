import base64
import uuid
from typing import Dict, Optional
from uuid import UUID

import httpx
from sqlalchemy.orm import Session

from app.core.config import settings
from app.models.db.github import GitHubPR, PRStatus
from app.services.fix_service import get_fix_request


async def create_github_pr_record(
    db: Session,
    fix_id: UUID,
    owner: str,
    repo: str,
    file_path: str,
    title: str,
    description: Optional[str] = None,
    base_branch: str = "main",
) -> GitHubPR:
    """
    Create a GitHub PR record in the database
    """
    # Generate a unique branch name
    branch_name = f"fix/{uuid.uuid4().hex[:8]}"
    
    # Create the PR record
    db_pr = GitHubPR(
        owner=owner,
        repo=repo,
        title=title,
        description=description,
        branch_name=branch_name,
        base_branch=base_branch,
    )
    
    db.add(db_pr)
    db.commit()
    db.refresh(db_pr)
    
    # Update the fix request with the PR ID
    fix = await get_fix_request(db, fix_id)
    if fix:
        fix.github_pr_id = db_pr.id
        db.commit()
    
    return db_pr


async def create_github_pr(db: Session, fix_id: UUID) -> str:
    """
    Create a GitHub PR with the fix
    """
    # Get the fix request
    fix = await get_fix_request(db, fix_id)
    if not fix:
        raise ValueError(f"Fix request with ID {fix_id} not found")
    
    # Get the GitHub PR record
    pr_record = db.query(GitHubPR).filter(GitHubPR.id == fix.github_pr_id).first()
    if not pr_record:
        raise ValueError(f"GitHub PR record not found for fix request {fix_id}")
    
    if not settings.GITHUB_ACCESS_TOKEN:
        raise ValueError("GitHub access token not configured")
    
    try:
        # GitHub API client
        headers = {
            "Authorization": f"token {settings.GITHUB_ACCESS_TOKEN}",
            "Accept": "application/vnd.github.v3+json",
        }
        
        # Get the default branch
        async with httpx.AsyncClient() as client:
            repo_response = await client.get(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}",
                headers=headers,
            )
            repo_response.raise_for_status()
            repo_data = repo_response.json()
            default_branch = repo_data["default_branch"]
        
        # Get the reference to the default branch
        async with httpx.AsyncClient() as client:
            ref_response = await client.get(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/git/refs/heads/{default_branch}",
                headers=headers,
            )
            ref_response.raise_for_status()
            ref_data = ref_response.json()
            base_sha = ref_data["object"]["sha"]
        
        # Create a new branch
        async with httpx.AsyncClient() as client:
            create_ref_response = await client.post(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/git/refs",
                headers=headers,
                json={
                    "ref": f"refs/heads/{pr_record.branch_name}",
                    "sha": base_sha,
                },
            )
            create_ref_response.raise_for_status()
        
        # Get the file content
        file_path = fix.github_pr.file_path
        async with httpx.AsyncClient() as client:
            file_response = await client.get(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/contents/{file_path}",
                headers=headers,
                params={"ref": default_branch},
            )
            file_response.raise_for_status()
            file_data = file_response.json()
            file_sha = file_data["sha"]
        
        # Update the file with the fix
        encoded_content = base64.b64encode(fix.fixed_code.encode("utf-8")).decode("utf-8")
        commit_message = f"Fix: {pr_record.title}"
        
        async with httpx.AsyncClient() as client:
            update_file_response = await client.put(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/contents/{file_path}",
                headers=headers,
                json={
                    "message": commit_message,
                    "content": encoded_content,
                    "sha": file_sha,
                    "branch": pr_record.branch_name,
                },
            )
            update_file_response.raise_for_status()
        
        # Create the PR
        pr_body = pr_record.description or "Automated fix generated by AgentLogger"
        pr_body += f"\n\nFix explanation:\n\n{fix.explanation}"
        
        async with httpx.AsyncClient() as client:
            pr_response = await client.post(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/pulls",
                headers=headers,
                json={
                    "title": pr_record.title,
                    "body": pr_body,
                    "head": pr_record.branch_name,
                    "base": pr_record.base_branch or default_branch,
                },
            )
            pr_response.raise_for_status()
            pr_data = pr_response.json()
        
        # Update the PR record
        pr_record.pr_number = pr_data["number"]
        pr_record.pr_url = pr_data["html_url"]
        db.commit()
        
        return pr_data["html_url"]
    
    except Exception as e:
        # Update the PR record status
        pr_record.status = PRStatus.CLOSED
        db.commit()
        
        raise ValueError(f"Failed to create GitHub PR: {str(e)}")


async def get_pr_status(db: Session, pr_id: UUID) -> Dict[str, str]:
    """
    Get the status of a GitHub PR
    """
    # Get the PR record
    pr_record = db.query(GitHubPR).filter(GitHubPR.id == pr_id).first()
    if not pr_record:
        raise ValueError(f"GitHub PR record with ID {pr_id} not found")
    
    if not pr_record.pr_number:
        return {
            "status": pr_record.status.value,
            "message": "PR has not been created yet",
        }
    
    if not settings.GITHUB_ACCESS_TOKEN:
        return {
            "status": pr_record.status.value,
            "message": "GitHub access token not configured, using cached status",
        }
    
    try:
        # GitHub API client
        headers = {
            "Authorization": f"token {settings.GITHUB_ACCESS_TOKEN}",
            "Accept": "application/vnd.github.v3+json",
        }
        
        # Get the PR status
        async with httpx.AsyncClient() as client:
            pr_response = await client.get(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/pulls/{pr_record.pr_number}",
                headers=headers,
            )
            pr_response.raise_for_status()
            pr_data = pr_response.json()
        
        # Update the PR record status
        if pr_data["merged"]:
            pr_record.status = PRStatus.MERGED
        elif pr_data["state"] == "closed":
            pr_record.status = PRStatus.CLOSED
        else:
            pr_record.status = PRStatus.OPEN
        
        db.commit()
        
        return {
            "status": pr_record.status.value,
            "message": f"PR is {pr_record.status.value}",
            "url": pr_record.pr_url,
        }
    
    except Exception as e:
        return {
            "status": pr_record.status.value,
            "message": f"Failed to get PR status: {str(e)}",
            "url": pr_record.pr_url,
        } 