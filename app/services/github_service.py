import base64
import uuid
from typing import Dict, Optional, List, Any
from uuid import UUID
import os
from datetime import datetime
from sqlalchemy.orm import Session
from github import Github, GithubException

import httpx
from sqlalchemy.orm import Session

from app.core.config import settings
from app.models.db.github import GitHubPR, PRStatus
from app.models.db.fix import FixRequest
from app.models.schemas.fix import FixRequestResponse
from app.services.fix_service import get_fix_request


class GitHubService:
    """
    Service for interacting with GitHub API
    """
    def __init__(self, access_token: Optional[str] = None):
        self.token = access_token or settings.GITHUB_ACCESS_TOKEN
        if not self.token:
            raise ValueError("GitHub access token not provided")
        
        self.client = Github(self.token)
    
    def create_pull_request(
        self, 
        repo_name: str,
        base_branch: str,
        head_branch: str,
        title: str,
        body: str,
        files_to_update: Dict[str, str]
    ) -> Dict[str, Any]:
        """
        Create a pull request with the specified changes
        """
        try:
            # Get the repository
            repo = self.client.get_repo(repo_name)
            
            # Get the base branch
            base_ref = repo.get_branch(base_branch)
            
            # Create a new branch
            try:
                repo.create_git_ref(
                    ref=f"refs/heads/{head_branch}",
                    sha=base_ref.commit.sha
                )
            except GithubException as e:
                # Branch might already exist
                if e.status != 422:  # 422 means branch already exists
                    raise
            
            # Update files in the branch
            for file_path, content in files_to_update.items():
                try:
                    # Try to get the file to update it
                    file = repo.get_contents(file_path, ref=head_branch)
                    repo.update_file(
                        path=file_path,
                        message=f"Fix: Update {file_path}",
                        content=content,
                        sha=file.sha,
                        branch=head_branch
                    )
                except GithubException:
                    # File doesn't exist, create it
                    repo.create_file(
                        path=file_path,
                        message=f"Fix: Create {file_path}",
                        content=content,
                        branch=head_branch
                    )
            
            # Create the pull request
            pr = repo.create_pull(
                title=title,
                body=body,
                base=base_branch,
                head=head_branch
            )
            
            return {
                "pr_number": pr.number,
                "pr_url": pr.html_url,
                "title": pr.title,
                "body": pr.body,
                "status": pr.state
            }
            
        except GithubException as e:
            raise Exception(f"GitHub API error: {e.data.get('message', str(e))}")
        except Exception as e:
            raise Exception(f"Error creating pull request: {str(e)}")


async def create_github_pr(
    db: Session, 
    fix_id: str, 
    repo_name: str,
    base_branch: str = "main",
    file_path: Optional[str] = None,
    fix_request: Optional[FixRequest] = None
) -> Dict[str, Any]:
    """
    Create a GitHub PR for a fix request
    """
    # Get the fix request if not provided
    if not fix_request:
        db_fix = db.query(FixRequest).filter(FixRequest.id == fix_id).first()
        if not db_fix:
            raise ValueError(f"Fix request with ID {fix_id} not found")
    else:
        db_fix = fix_request
    
    if db_fix.status != "completed":
        raise ValueError(f"Cannot create PR for fix request with status {db_fix.status}")
    
    # Create a unique branch name
    timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S")
    head_branch = f"fix/{fix_id}-{timestamp}"
    
    # Determine file path if not provided
    if not file_path:
        file_path = f"fix_{fix_id}.{db_fix.language.lower()}"
    
    # Create PR title and body
    title = f"Fix: {db_fix.error_message[:50]}..." if db_fix.error_message else f"Fix for issue #{fix_id}"
    body = f"""
    Automated fix generated by AgentLogger

    ## Original Error
    ```
    {db_fix.error_message}
    ```

    ## Explanation
    {db_fix.explanation}

    ## Fix ID
    {fix_id}
    """
    
    # Create GitHub service and PR
    github_service = GitHubService()
    pr_data = github_service.create_pull_request(
        repo_name=repo_name,
        base_branch=base_branch,
        head_branch=head_branch,
        title=title,
        body=body,
        files_to_update={file_path: db_fix.fixed_code}
    )
    
    # Save PR data to database
    db_pr = GitHubPR(
        fix_id=fix_id,
        repo_name=repo_name,
        pr_number=pr_data["pr_number"],
        pr_url=pr_data["pr_url"],
        status=pr_data["status"]
    )
    
    db.add(db_pr)
    db.commit()
    db.refresh(db_pr)
    
    return pr_data


async def get_github_prs_for_fix(db: Session, fix_id: str) -> List[Dict[str, Any]]:
    """
    Get all GitHub PRs for a fix request
    """
    db_prs = db.query(GitHubPR).filter(GitHubPR.fix_id == fix_id).all()
    return [
        {
            "id": str(pr.id),
            "repo_name": pr.repo_name,
            "pr_number": pr.pr_number,
            "pr_url": pr.pr_url,
            "status": pr.status,
            "created_at": pr.created_at.isoformat() if pr.created_at else None
        }
        for pr in db_prs
    ]


async def create_github_pr_record(
    db: Session,
    fix_id: UUID,
    owner: str,
    repo: str,
    file_path: str,
    title: str,
    description: Optional[str] = None,
    base_branch: str = "main",
) -> GitHubPR:
    """
    Create a GitHub PR record in the database
    """
    # Generate a unique branch name
    branch_name = f"fix/{uuid.uuid4().hex[:8]}"
    
    # Create the PR record
    db_pr = GitHubPR(
        owner=owner,
        repo=repo,
        title=title,
        description=description,
        branch_name=branch_name,
        base_branch=base_branch,
    )
    
    db.add(db_pr)
    db.commit()
    db.refresh(db_pr)
    
    # Update the fix request with the PR ID
    fix = db.query(FixRequest).filter(FixRequest.id == fix_id).first()
    if fix:
        fix.github_pr_id = db_pr.id
        db.commit()
    
    return db_pr


async def create_github_pr(db: Session, fix_id: UUID) -> str:
    """
    Create a GitHub PR with the fix
    """
    # Get the fix request
    fix = await get_fix_request(db, fix_id)
    if not fix:
        raise ValueError(f"Fix request with ID {fix_id} not found")
    
    # Get the GitHub PR record
    pr_record = db.query(GitHubPR).filter(GitHubPR.id == fix.github_pr_id).first()
    if not pr_record:
        raise ValueError(f"GitHub PR record not found for fix request {fix_id}")
    
    if not settings.GITHUB_ACCESS_TOKEN:
        raise ValueError("GitHub access token not configured")
    
    try:
        # GitHub API client
        headers = {
            "Authorization": f"token {settings.GITHUB_ACCESS_TOKEN}",
            "Accept": "application/vnd.github.v3+json",
        }
        
        # Get the default branch
        async with httpx.AsyncClient() as client:
            repo_response = await client.get(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}",
                headers=headers,
            )
            repo_response.raise_for_status()
            repo_data = repo_response.json()
            default_branch = repo_data["default_branch"]
        
        # Get the reference to the default branch
        async with httpx.AsyncClient() as client:
            ref_response = await client.get(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/git/refs/heads/{default_branch}",
                headers=headers,
            )
            ref_response.raise_for_status()
            ref_data = ref_response.json()
            base_sha = ref_data["object"]["sha"]
        
        # Create a new branch
        async with httpx.AsyncClient() as client:
            create_ref_response = await client.post(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/git/refs",
                headers=headers,
                json={
                    "ref": f"refs/heads/{pr_record.branch_name}",
                    "sha": base_sha,
                },
            )
            create_ref_response.raise_for_status()
        
        # Get the file content
        file_path = fix.github_pr.file_path
        async with httpx.AsyncClient() as client:
            file_response = await client.get(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/contents/{file_path}",
                headers=headers,
                params={"ref": default_branch},
            )
            file_response.raise_for_status()
            file_data = file_response.json()
            file_sha = file_data["sha"]
        
        # Update the file with the fix
        encoded_content = base64.b64encode(fix.fixed_code.encode("utf-8")).decode("utf-8")
        commit_message = f"Fix: {pr_record.title}"
        
        async with httpx.AsyncClient() as client:
            update_file_response = await client.put(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/contents/{file_path}",
                headers=headers,
                json={
                    "message": commit_message,
                    "content": encoded_content,
                    "sha": file_sha,
                    "branch": pr_record.branch_name,
                },
            )
            update_file_response.raise_for_status()
        
        # Create the PR
        pr_body = pr_record.description or "Automated fix generated by AgentLogger"
        pr_body += f"\n\nFix explanation:\n\n{fix.explanation}"
        
        async with httpx.AsyncClient() as client:
            pr_response = await client.post(
                f"https://api.github.com/repos/{pr_record.owner}/{pr_record.repo}/pulls",
                headers=headers,
                json={
                    "title": pr_record.title,
                    "body": pr_body,
                    "head": pr_record.branch_name,
                    "base": pr_record.base_branch or default_branch,
                },
            )
            pr_response.raise_for_status()
            pr_data = pr_response.json()
        
        # Update the PR record
        pr_record.pr_number = pr_data["number"]
        pr_record.pr_url = pr_data["html_url"]
        db.commit()
        
        return pr_data["html_url"]
    
    except Exception as e:
        # Update the PR record status
        pr_record.status = PRStatus.CLOSED
        db.commit()
        
        raise ValueError(f"Failed to create GitHub PR: {str(e)}")


async def get_pr_status(db: Session, pr_id: UUID) -> Dict[str, str]:
    """
    Get the status of a GitHub PR
    """
    pr = db.query(GitHubPR).filter(GitHubPR.id == pr_id).first()
    if not pr:
        raise ValueError(f"PR with ID {pr_id} not found")
    
    # If we have a PR URL, check the status from GitHub
    if pr.pr_url:
        try:
            # Extract owner and repo from the PR URL
            # Example URL: https://github.com/owner/repo/pull/123
            parts = pr.pr_url.split("/")
            owner = parts[-4]
            repo = parts[-3]
            pr_number = int(parts[-1])
            
            # Create GitHub client
            github_service = GitHubService()
            github_repo = github_service.client.get_repo(f"{owner}/{repo}")
            github_pr = github_repo.get_pull(pr_number)
            
            # Update status in database
            pr.status = github_pr.state
            db.commit()
            
            return {
                "status": pr.status,
                "pr_url": pr.pr_url
            }
        except Exception as e:
            return {
                "status": pr.status,
                "pr_url": pr.pr_url,
                "error": str(e)
            }
    
    return {
        "status": pr.status,
        "pr_url": pr.pr_url or "No PR URL available"
    } 